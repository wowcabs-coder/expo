{"version":3,"file":"generate.js","sourceRoot":"","sources":["../../src/typed-routes/generate.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\n\nimport { RouteNode } from '../Route';\nimport { getRoutes } from '../getRoutes';\nimport { matchDynamicName, removeSupportedExtensions } from '../matchers';\nimport { RequireContext } from '../types';\n\n// /[...param1]/ - Match [...param1]\nconst CATCH_ALL = /\\[\\.\\.\\..+?\\]/g;\n// /[param1] - Match [param1]\nconst SLUG = /\\[.+?\\]/g;\n// /(group)/path/(group2)/route - Match [(group), (group2)]\nconst GROUP = /(?:^|\\/)\\(.*?\\)/g;\n\nexport function getTypedRoutesDeclarationFile(ctx: RequireContext) {\n  let routeNode: RouteNode | null = null;\n\n  const partialTypedGroups: boolean =\n    Constants.expoConfig?.extra?.router.partialTypedGroups || true;\n\n  try {\n    routeNode = getRoutes(ctx, {\n      ignore: [/_layout\\.[tj]sx?$/], // Skip layout files\n      platformRoutes: false, // We don't need to generate platform specific routes\n      notFound: false, // We don't need +not-found routes either\n      ignoreEntryPoints: true,\n      ignoreRequireErrors: true,\n      importMode: 'async', // Don't load the file\n    });\n  } catch {\n    // Ignore errors from `getRoutes`. This is also called inside the app, which has\n    // a nicer UX for showing error messages\n  }\n\n  const groupedNodes = groupRouteNodes(routeNode);\n  const staticRoutesStrings: string[] = [];\n  const staticRoutesObjects: string[] = [];\n\n  for (const type of groupedNodes.static) {\n    staticRoutesStrings.push(\n      contextKeyToType(type + \"${`?${string}` | `#${string}` | ''}\", partialTypedGroups)\n    );\n    staticRoutesObjects.push(\n      `{ pathname: ${contextKeyToType(type, partialTypedGroups)}; params?: UnknownInputParams | never; }`\n    );\n  }\n\n  const staticRoutes = [\n    'Router.RelativePathString',\n    'Router.ExternalPathString',\n    ...staticRoutesStrings,\n    ...staticRoutesObjects,\n  ];\n\n  const dynamicRouteTypes: string[] = [];\n  const dynamicRouteTemplateTypes: string[] = [];\n  const hrefParamsEntries: [string, string][] = [];\n\n  for (const [dynamicRouteTemplate, paramsNames] of groupedNodes.dynamic) {\n    const params = paramsNames\n      .map((param) => {\n        const key = matchDynamicName(param);\n        const value = param.startsWith('[...') ? '(string | number)[]' : 'string | number';\n        return `${key}: ${value};`;\n      })\n      .join('');\n\n    let paramsString = '';\n    if (params.length) {\n      paramsString = ` & { ${params} }`;\n      hrefParamsEntries.push([\n        contextKeyToType(dynamicRouteTemplate, partialTypedGroups),\n        paramsString,\n      ]);\n    }\n\n    dynamicRouteTypes.push(\n      contextKeyToType(\n        dynamicRouteTemplate\n          .replaceAll(CATCH_ALL, '${string}')\n          .replaceAll(SLUG, '${Router.SingleRoutePart<T>}'),\n        partialTypedGroups\n      )\n    );\n\n    dynamicRouteTemplateTypes.push(\n      `{ pathname: ${contextKeyToType(dynamicRouteTemplate, partialTypedGroups)}, params: Router.UnknownInputParams${paramsString} }`\n    );\n  }\n\n  const hrefParams = hrefParamsEntries\n    .map(([key, value]) => {\n      return `Record<${key}, ${value}>`;\n    })\n    .join(' | ');\n\n  return `/* eslint-disable */\nimport * as Router from 'expo-router';\n\nexport * from 'expo-router';\n\ndeclare module 'expo-router' {\n  export namespace ExpoRouter {\n    export interface __routes<T extends string = string> extends Record<string, unknown> {\n      HrefParams: ${hrefParams};\n      Href: ${[...staticRoutes, ...dynamicRouteTypes, ...dynamicRouteTemplateTypes].join(' | ')};\n    }\n  }\n}\n`;\n}\n\nfunction groupRouteNodes(\n  routeNode: RouteNode | null,\n  groupedContextKeys = {\n    static: new Set<string>(),\n    dynamic: new Map<string, string[]>(),\n  }\n) {\n  if (!routeNode) {\n    return groupedContextKeys;\n  }\n\n  // Skip non-route files\n  if (routeNode.type !== 'route') {\n    // Except the root layout\n    if (routeNode.route === '') {\n      for (const child of routeNode.children) {\n        groupRouteNodes(child, groupedContextKeys);\n      }\n      return groupedContextKeys;\n    }\n\n    return groupedContextKeys;\n  }\n\n  let routeKey: string;\n\n  if (routeNode.generated) {\n    // Some routes like the root _layout, _sitemap, +not-found are generated.\n    // We cannot use the contextKey, as their context key does not specify a route\n    routeKey = routeNode.route;\n  } else {\n    routeKey = removeSupportedExtensions(routeNode.contextKey)\n      .replace(/\\/index$/, '') // Remove any trailing /index\n      .replace(/^\\./, ''); // Remove any leading .\n  }\n\n  routeKey ||= '/'; // A routeKey may be empty for contextKey '' or './index.js'\n\n  if (!routeKey.startsWith('/')) {\n    // Not all generated files will have the `/` prefix\n    routeKey = `/${routeKey}`;\n  }\n\n  if (routeNode.dynamic) {\n    groupedContextKeys.dynamic.set(\n      routeKey,\n      routeKey.split('/').filter((segment) => {\n        return segment.startsWith('[') && segment.endsWith(']');\n      })\n    );\n  } else {\n    groupedContextKeys.static.add(routeKey);\n  }\n\n  for (const child of routeNode.children) {\n    groupRouteNodes(child, groupedContextKeys);\n  }\n\n  return groupedContextKeys;\n}\n\nfunction contextKeyToType(contextKey: string, partialTypedGroups: boolean) {\n  // If the route has groups, turn them into template strings\n  const typeWithGroups = contextKey.replaceAll(GROUP, (match) => {\n    const groups = match.slice(2, -1); // Remove the leading ( and the trailing )\n    // When `partialRoutes` is enabled, we always change a group to a template\n    if (groups.length > 1 || partialTypedGroups) {\n      // Ensure each group has the trailing slash\n      const groupsAsType = groups.split(',').map((group) => `'/(${group})'`);\n      // `partialRoutes` allow you to skip a group\n      if (partialTypedGroups) {\n        groupsAsType.push(\"''\");\n      }\n      // Combine together into a union\n      return `\\${${groupsAsType.join(' | ')}}`;\n    } else {\n      return match;\n    }\n  });\n\n  const typeWithoutGroups = contextKey.replaceAll(GROUP, '');\n\n  return `\\`${typeWithGroups}\\` | ${typeWithoutGroups}`;\n}\n"]}